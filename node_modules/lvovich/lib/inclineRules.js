"use strict";
/* eslint-disable no-use-before-define, no-continue, arrow-parens */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeclensionStr = exports.getDeclensionConst = exports.applyMod = exports.applyRule = exports.findExactRule = exports.findRule = exports.inclineByRules = exports.constantizeGenderInRules = exports.PREPOSITIONAL = exports.INSTRUMENTAL = exports.ACCUSATIVE = exports.DATIVE = exports.GENITIVE = exports.NOMINATIVE = void 0;
const utils_1 = require("./utils");
const gender_1 = require("./gender");
exports.NOMINATIVE = 1; // именительный
exports.GENITIVE = 2; // родительный
exports.DATIVE = 3; // дательный
exports.ACCUSATIVE = 4; // винительный
exports.INSTRUMENTAL = 5; // творительный
exports.PREPOSITIONAL = 6; // предложный
function constantizeGenderInRules(rules) {
    if (Array.isArray(rules.exceptions)) {
        rules.exceptions.forEach((rule) => {
            rule.gender = (0, gender_1.getGenderConst)(rule.gender); // eslint-disable-line
        });
    }
    if (Array.isArray(rules.suffixes)) {
        rules.suffixes.forEach((rule) => {
            rule.gender = (0, gender_1.getGenderConst)(rule.gender); // eslint-disable-line
        });
    }
}
exports.constantizeGenderInRules = constantizeGenderInRules;
function inclineByRules(str, declensionStr, genderStr, ruleSet) {
    const declension = getDeclensionConst(declensionStr);
    const gender = (0, gender_1.getGenderConst)(genderStr);
    const parts = str.split('-');
    const result = [];
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isFirstWord = i === 0 && parts.length > 1;
        const rule = findRule(part, gender, ruleSet, {
            firstWord: isFirstWord,
        });
        if (rule) {
            result.push(applyRule(rule, part, declension));
        }
        else {
            result.push(part);
        }
    }
    return result.join('-');
}
exports.inclineByRules = inclineByRules;
function findRule(str, gender, ruleSet, tags = {}) {
    if (!str) {
        return null;
    }
    const strLower = str.toLowerCase();
    const tagList = [];
    Object.keys(tags).forEach((key) => {
        if (tags[key]) {
            tagList.push(key);
        }
    });
    if (ruleSet.exceptions) {
        const rule = findExactRule(ruleSet.exceptions, gender, (some) => some === strLower, tagList);
        if (rule)
            return rule;
    }
    return ruleSet.suffixes
        ? findExactRule(ruleSet.suffixes, gender, (some) => (0, utils_1.endsWith)(strLower, some), tagList)
        : null;
}
exports.findRule = findRule;
function findExactRule(rules, gender, matchFn, tags = []) {
    for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        // rule with tag should be skipped if tag not listed in args
        if (rule.tags) {
            if (!rule.tags.find((t) => tags.indexOf(t) !== -1)) {
                continue;
            }
        }
        // rule must have same gender or be `androgynous`
        if (rule.gender !== gender_1.ANDROGYNOUS && gender !== rule.gender) {
            continue;
        }
        if (rule.test) {
            for (let j = 0; j < rule.test.length; j++) {
                if (matchFn(rule.test[j])) {
                    return rule;
                }
            }
        }
    }
    return null;
}
exports.findExactRule = findExactRule;
function getModByIdx(mods, i) {
    if (mods && mods.length >= i) {
        return mods[i];
    }
    return '.';
}
function applyRule(rule, str, declension) {
    let mod;
    switch (declension) {
        case exports.NOMINATIVE:
            mod = '.';
            break;
        case exports.GENITIVE:
            mod = getModByIdx(rule.mods, 0);
            break;
        case exports.DATIVE:
            mod = getModByIdx(rule.mods, 1);
            break;
        case exports.ACCUSATIVE:
            mod = getModByIdx(rule.mods, 2);
            break;
        case exports.INSTRUMENTAL:
            mod = getModByIdx(rule.mods, 3);
            break;
        case exports.PREPOSITIONAL:
            mod = getModByIdx(rule.mods, 4);
            break;
        default:
            mod = '.';
    }
    return applyMod(str, mod);
}
exports.applyRule = applyRule;
function applyMod(str, mod) {
    for (let i = 0; i < mod.length; i++) {
        const chr = mod[i];
        switch (chr) {
            case '.':
                break;
            case '-':
                str = str.substr(0, str.length - 1); // eslint-disable-line no-param-reassign
                break;
            default:
                str += chr; // eslint-disable-line no-param-reassign
        }
    }
    return str;
}
exports.applyMod = applyMod;
function getDeclensionConst(key) {
    switch (key) {
        case 'nominative':
        case exports.NOMINATIVE:
            return exports.NOMINATIVE;
        case 'genitive':
        case exports.GENITIVE:
            return exports.GENITIVE;
        case 'dative':
        case exports.DATIVE:
            return exports.DATIVE;
        case 'accusative':
        case exports.ACCUSATIVE:
            return exports.ACCUSATIVE;
        case 'instrumental':
        case exports.INSTRUMENTAL:
            return exports.INSTRUMENTAL;
        case 'prepositional':
        case exports.PREPOSITIONAL:
            return exports.PREPOSITIONAL;
        default:
            return null;
    }
}
exports.getDeclensionConst = getDeclensionConst;
function getDeclensionStr(cnst) {
    switch (cnst) {
        case 'nominative':
        case exports.NOMINATIVE:
            return 'nominative';
        case 'genitive':
        case exports.GENITIVE:
            return 'genitive';
        case 'dative':
        case exports.DATIVE:
            return 'dative';
        case 'accusative':
        case exports.ACCUSATIVE:
            return 'accusative';
        case 'instrumental':
        case exports.INSTRUMENTAL:
            return 'instrumental';
        case 'prepositional':
        case exports.PREPOSITIONAL:
            return 'prepositional';
        default:
            return null;
    }
}
exports.getDeclensionStr = getDeclensionStr;
//# sourceMappingURL=inclineRules.js.map